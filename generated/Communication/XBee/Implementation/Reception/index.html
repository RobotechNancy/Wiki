<!DOCTYPE html>

<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Wiki Robotech Nancy - Réception de données</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Implémentation de la réception de données">

		<link rel="stylesheet" href="http://127.0.0.1:8000/static/style.css">
		<link rel="apple-touch-icon" href="http://127.0.0.1:8000/static/images/icons/logo.webp">
		<link rel="icon" type="image/webp" href="http://127.0.0.1:8000/static/images/icons/logo.webp">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700&display=swap">
	</head>

	<body>
		<header>
			<h1>
				<a href="http://127.0.0.1:8000/">
					<img src="http://127.0.0.1:8000/static/images/icons/logo.webp" width="40" height="40" alt="Logo Robotech Nancy">
					<span>Wiki Robotech Nancy</span>
				</a>
				<button type="button" class="open-nav" aria-label="Ouvrir la navigation" onclick="document.body.classList.toggle('nav-open')"></button>
			</h1>

			<nav>
				<div>
					
    

    <a href="http://127.0.0.1:8000/Cartes/">Cartes utilisées</a>
    

    <a href="http://127.0.0.1:8000/Wiki/">Modifier ce wiki</a>
    

    <details>
        <summary>CMake</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/CMake/Installation/">Installer CMake</a>
    

    <a href="http://127.0.0.1:8000/CMake/Executable/">Créer un exécutable</a>
    

    <a href="http://127.0.0.1:8000/CMake/Lier/">Lier des librairies</a>
    

    <a href="http://127.0.0.1:8000/CMake/Librairie/">Créer une librairie</a>
    

        </div>
    </details>
    

    <details>
        <summary>STM32</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/STM32/Installation/">Installation</a>
    

    <a href="http://127.0.0.1:8000/STM32/Projet/">Créer un projet</a>
    

    <a href="http://127.0.0.1:8000/STM32/CubeMX/">Configurer une carte</a>
    

        </div>
    </details>
    

    <details>
        <summary>Communication</summary>
        <div>
            
    <details>
        <summary>XBee</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/Communication/XBee/Principe/">Principe</a>
    

    <a href="http://127.0.0.1:8000/Communication/XBee/Librairie/">Utiliser la librairie</a>
    

    <details>
        <summary>Implémentation</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/Communication/XBee/Implementation/Format/">Format des trames</a>
    

    <a href="http://127.0.0.1:8000/Communication/XBee/Implementation/Initialisation/">Initialisation</a>
    

    <a href="http://127.0.0.1:8000/Communication/XBee/Implementation/Reception/">Réception de données</a>
    

    <a href="http://127.0.0.1:8000/Communication/XBee/Implementation/Envoi/">Envoi de données</a>
    

        </div>
    </details>
    

        </div>
    </details>
    

    <details>
        <summary>CAN</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/Communication/CAN/Principe/">Principe</a>
    

    <a href="http://127.0.0.1:8000/Communication/CAN/Raspberry/">Librairie Raspberry</a>
    

    <a href="http://127.0.0.1:8000/Communication/CAN/STM32/">Librairie STM32</a>
    

    <details>
        <summary>Implémentation</summary>
        <div>
            
    <a href="http://127.0.0.1:8000/Communication/CAN/Implementation/Format/">Format des trames</a>
    

    <a href="http://127.0.0.1:8000/Communication/CAN/Implementation/Librairie/">Initialisation</a>
    

    <a href="http://127.0.0.1:8000/Communication/CAN/Implementation/Reception/">Réception de données</a>
    

    <a href="http://127.0.0.1:8000/Communication/CAN/Implementation/Envoi/">Envoi de données</a>
    

        </div>
    </details>
    

        </div>
    </details>
    

        </div>
    </details>
    

				</div>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Communication/XBee/Implementation/Reception</h2>
				<h3 class="no-anchor">Réception de données</h3>
			</div>
			<article class="content">
				<p>Pour démarrer la réception de données, il faut appeler <code>XBee::startListening</code>.
En interne, cette fonction démarre un thread qui vérifie toutes les 10ms si des données sont disponibles (avec <code>seriallib::available</code>).</p>
<p>Si des données sont disponibles, elles sont lues avec <code>XBee::readRx</code> avec un timeout de 100ms.
Un délai de 2ms est ajouté entre chaque lecture pour éviter d'arrêter la lecture du buffer de réception alors qu'il y a encore des données à lire.</p>
<p>Une fois les données lues, elles sont traitées par <code>XBee::processBuffer</code> qui a pour but de vérifier que les données reçues correspondent à une trame valide.</p>
<blockquote>
<p class="quote quote-WARNING">Pour l'instant, le cas où plusieurs trames sont reçues en même temps n'est pas géré.</p>
</blockquote>
<h3>Gestion des réponses</h3>
<p>Il y a deux manières de recevoir des données :</p>
<ul>
<li>Asynchrone : ne bloque pas l'exécution du programme principal et utilise des callbacks</li>
<li>Synchrone : bloque l'exécution du programme principal et utilise <code>XBee::send</code></li>
</ul>
<div class="codehilite"><pre tabindex='0'><span></span><code><span class="c1">// On veut récupérer les positions de tous les tag ArUco</span>
<span class="c1">// Aucune données à envoyer, 5 secondes de timeout</span>
<span class="n">xbee_result_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xbee</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">XB_ADDR_CAMERA_01</span><span class="p">,</span><span class="w"> </span><span class="n">XB_FCT_GET_ARUCO_POS</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>

<span class="k">switch</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">XB_E_SUCCESS</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// Trame disponible avec res.frame</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Positions reçues !&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">XB_E_FRAME_TIMEOUT</span><span class="p">:</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Aucune réponse reçue en 5 secondes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Une erreur est survenue :(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Multi-threading</h3>
<p>Comme l'écoute est asynchrone, un mutex est utilisé pour gérer les accès simultanés entre deux threads.
Par exemple, quand une réponse est reçu, l'accès à <code>XBee::responses</code> est bloqué le temps de l'insertion: </p>
<div class="codehilite"><pre tabindex='0'><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">responseMutex</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">responses</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">frameId</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">responses</span><span class="p">[</span><span class="n">frame</span><span class="p">.</span><span class="n">frameId</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">XB_E_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Similairement, la boucle d'écoute utilise un booléen atomique pour savoir si l'écoute est en pause ou non.
L'utilisation de <code>std::atomic</code> n'est pas obligatoire ici mais on veut un comportement prévisible lorsque qu'on modifie l'état de l'écoute :</p>
<div class="codehilite"><pre tabindex='0'><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isListening</span><span class="p">.</span><span class="n">load</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">readRx</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
<span class="w">        </span><span class="n">processBuffer</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3>Libération de la mémoire</h3>
<p>Au lieu d'utiliser des raw pointers (ex. <code>std::thread*</code>), on utilise <code>std::unique_ptr</code>.
Ici la seule différence qui nous intéresse est que la mémoire derrière le pointeur (ex. <code>std::thread</code>) est libérée automatiquement.</p>
			</article>
		</section>

		<script src="http://127.0.0.1:8000/static/script.js"></script>
	</body>
</html>