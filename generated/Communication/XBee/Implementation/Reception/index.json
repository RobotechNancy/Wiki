{
    "hidden": "false",
    "title": "R\u00e9ception de donn\u00e9es",
    "description": "Impl\u00e9mentation de la r\u00e9ception de donn\u00e9es",
    "order": "3",
    "uri": "Communication/XBee/Implementation/Reception",
    "page_content": "<p>Pour d\u00e9marrer la r\u00e9ception de donn\u00e9es, il faut appeler <code>XBee::startListening</code>.\nEn interne, cette fonction d\u00e9marre un thread qui v\u00e9rifie toutes les 10ms si des donn\u00e9es sont disponibles (avec <code>seriallib::available</code>).</p>\n<p>Si des donn\u00e9es sont disponibles, elles sont lues avec <code>XBee::readRx</code> avec un timeout de 100ms.\nUn d\u00e9lai de 2ms est ajout\u00e9 entre chaque lecture pour \u00e9viter d'arr\u00eater la lecture du buffer de r\u00e9ception alors qu'il y a encore des donn\u00e9es \u00e0 lire.</p>\n<p>Une fois les donn\u00e9es lues, elles sont trait\u00e9es par <code>XBee::processBuffer</code> qui a pour but de v\u00e9rifier que les donn\u00e9es re\u00e7ues correspondent \u00e0 une trame valide.</p>\n<blockquote>\n<p class=\"quote quote-WARNING\">Pour l'instant, le cas o\u00f9 plusieurs trames sont re\u00e7ues en m\u00eame temps n'est pas g\u00e9r\u00e9.</p>\n</blockquote>\n<h3>Gestion des r\u00e9ponses</h3>\n<p>Il y a deux mani\u00e8res de recevoir des donn\u00e9es :</p>\n<ul>\n<li>Asynchrone : ne bloque pas l'ex\u00e9cution du programme principal et utilise des callbacks</li>\n<li>Synchrone : bloque l'ex\u00e9cution du programme principal et utilise <code>XBee::send</code></li>\n</ul>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"c1\">// On veut r\u00e9cup\u00e9rer les positions de tous les tag ArUco</span>\n<span class=\"c1\">// Aucune donn\u00e9es \u00e0 envoyer, 5 secondes de timeout</span>\n<span class=\"n\">xbee_result_t</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">xbee</span><span class=\"p\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">XB_ADDR_CAMERA_01</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">XB_FCT_GET_ARUCO_POS</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">)</span>\n\n<span class=\"k\">switch</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">XB_E_SUCCESS</span><span class=\"p\">:</span>\n<span class=\"w\">        </span><span class=\"c1\">// Trame disponible avec res.frame</span>\n<span class=\"w\">        </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;Positions re\u00e7ues !&quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">break</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">XB_E_FRAME_TIMEOUT</span><span class=\"p\">:</span>\n<span class=\"w\">        </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;Aucune r\u00e9ponse re\u00e7ue en 5 secondes&quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">break</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">default</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;Une erreur est survenue :(&quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<h3>Multi-threading</h3>\n<p>Comme l'\u00e9coute est asynchrone, un mutex est utilis\u00e9 pour g\u00e9rer les acc\u00e8s simultan\u00e9s entre deux threads.\nPar exemple, quand une r\u00e9ponse est re\u00e7u, l'acc\u00e8s \u00e0 <code>XBee::responses</code> est bloqu\u00e9 le temps de l'insertion: </p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">responseMutex</span><span class=\"p\">);</span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">responses</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">frameId</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">responses</span><span class=\"p\">[</span><span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">frameId</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">XB_E_SUCCESS</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<p>Similairement, la boucle d'\u00e9coute utilise un bool\u00e9en atomique pour savoir si l'\u00e9coute est en pause ou non.\nL'utilisation de <code>std::atomic</code> n'est pas obligatoire ici mais on veut un comportement pr\u00e9visible lorsque qu'on modifie l'\u00e9tat de l'\u00e9coute :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">isListening</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">sleep_for</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">milliseconds</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">));</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">serial</span><span class=\"p\">.</span><span class=\"n\">available</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">readRx</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"n\">processBuffer</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<h3>Lib\u00e9ration de la m\u00e9moire</h3>\n<p>Au lieu d'utiliser des raw pointers (ex. <code>std::thread*</code>), on utilise <code>std::unique_ptr</code>.\nIci la seule diff\u00e9rence qui nous int\u00e9resse est que la m\u00e9moire derri\u00e8re le pointeur (ex. <code>std::thread</code>) est lib\u00e9r\u00e9e automatiquement.</p>"
}