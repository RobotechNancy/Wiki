{
    "hidden": "false",
    "title": "R\u00e9ception de donn\u00e9es",
    "description": "Impl\u00e9mentation de la r\u00e9ception de donn\u00e9es",
    "order": "3",
    "uri": "Communication/CAN/Implementation/Reception",
    "page_content": "<h3>C\u00f4t\u00e9 STM32</h3>\n<p>Pour r\u00e9cup\u00e9rer les donn\u00e9es re\u00e7ues et la formater en <code>can_frame_t</code>, on utilise <code>CAN_RECEIVE</code> :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"c1\">// Champ de donn\u00e9es</span>\n<span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">RxData</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">];</span>\n<span class=\"c1\">// Structure de la trame</span>\n<span class=\"n\">CAN_RxHeaderTypeDef</span><span class=\"w\"> </span><span class=\"n\">RxHeader</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// R\u00e9cup\u00e9rer la trame, Rx = buffer de r\u00e9ception</span>\n<span class=\"n\">HAL_CAN_GetRxMessage</span><span class=\"p\">(</span><span class=\"n\">hcan</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CAN_RX_FIFO0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">RxHeader</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">RxData</span><span class=\"p\">);</span>\n</code></pre></div>\n\n<p>Pour r\u00e9cup\u00e9rer les diff\u00e9rents champs contenu dans l'identifiant \u00e9tendu, on applique des masques et des d\u00e9calages, par exemple, pour r\u00e9cup\u00e9rer l'adresse du destinataire :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"n\">can_frame_t</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"p\">;</span>\n<span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">receiverAddress</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">RxHeader</span><span class=\"p\">.</span><span class=\"n\">ExtId</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">CAN_MASK_RECEIVER_ADDR</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">CAN_OFFSET_RECEIVER_ADDR</span><span class=\"p\">;</span>\n</code></pre></div>\n\n<h3>C\u00f4t\u00e9 Raspberry</h3>\n<p>Pour r\u00e9cup\u00e9rer les donn\u00e9es de mani\u00e8re non bloquante, on utilise un thread s\u00e9par\u00e9 :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"n\">isListening</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"n\">listenerThread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">make_unique</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">CAN</span><span class=\"o\">::</span><span class=\"n\">listen</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">this</span><span class=\"p\">);</span>\n</code></pre></div>\n\n<p>Ici <code>isListening</code> est atomique, c'est-\u00e0-dire que si plusieurs threads tentent de le modifier en m\u00eame temps, il n'y aura pas de probl\u00e8me.\nSimilairement, <code>listenerThread</code> est un pointeur intelligent qui se d\u00e9truira automatiquement \u00e0 la fin du programme.</p>\n<p>Pour savoir si des donn\u00e9es sont disponibles, on fait du polling :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"c1\">// On est int\u00e9ress\u00e9 que par l&#39;\u00e9v\u00e9nement POLLIN</span>\n<span class=\"c1\">// qui indique que des donn\u00e9es sont disponibles</span>\n<span class=\"n\">pollfd</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">socket</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">POLLIN</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">};</span>\n\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">isListening</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">fd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// timeout, aucune donn\u00e9e disponible</span>\n<span class=\"w\">        </span><span class=\"k\">continue</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// erreur</span>\n<span class=\"w\">        </span><span class=\"k\">break</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Donn\u00e9es disponibles</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<p>D\u00e8s que des donn\u00e9es sont disponibles, on les r\u00e9cup\u00e8re :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"n\">can_frame</span><span class=\"w\"> </span><span class=\"n\">buffer</span><span class=\"p\">{};</span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">socket</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">can_frame</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// Erreur lors de la lecture</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Puis m\u00eame formatage que sur STM32 (seul la structure qui contient les donn\u00e9es change)</span>\n</code></pre></div>\n\n<p>Si la trame est une r\u00e9ponse <code>frame.isResponse</code>, on la stocke dans un tableau ce qui permet de d\u00e9bloquer la fonction qui attend cette r\u00e9ponse :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">isResponse</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">responses</span><span class=\"p\">[</span><span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">messageID</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<p>Ici on utilise un mutex et <code>std::lock_guard</code> pour \u00e9viter que deux threads tentent de modifier <code>responses</code> en m\u00eame temps.\n<code>std::lock_guard</code> est un pointeur intelligent qui bloque le mutex \u00e0 sa cr\u00e9ation et le d\u00e9bloque \u00e0 sa destruction.</p>\n<p>Si la trame n'est pas une r\u00e9ponse, on cherche si son code fonction a un callback associ\u00e9 :</p>\n<div class=\"codehilite\"><pre tabindex='0'><span></span><code><span class=\"k\">auto</span><span class=\"w\"> </span><span class=\"n\">callback</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">callbacks</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">frame</span><span class=\"p\">.</span><span class=\"n\">functionCode</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// callback.first = code fonction</span>\n<span class=\"c1\">// callback.second = fonction associ\u00e9e</span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">callback</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">callbacks</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">callback</span><span class=\"o\">-&gt;</span><span class=\"n\">second</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<p>Et si aucune fonction n'est associ\u00e9e, on l'ignore simplement.</p>"
}